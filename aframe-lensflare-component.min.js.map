{"version":3,"sources":["webpack:///aframe-lensflare-component.min.js","webpack:///webpack/bootstrap 2c280269332efe31211c?d5b9","webpack:///./index.js?2645","webpack:///./Lensflare.js?f53d"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","AFRAME","Error","THREE","registerComponent","schema","src","type","createLight","default","position","target","intensity","relative","size","lightColor","lightDistance","lightAngle","Math","PI","lightPenumbra","lightDecay","lightType","oneOf","multiple","setLightType","settings","SpotLight","Color","PointLight","DirectionalLight","init","scene","document","querySelector","object3D","parentEl","this","el","sceneEl","data","Vector3","textureLoader","TextureLoader","textureFlare","load","currentSrc","texture","undefined","error","lensFlare","Lensflare","lensFlareElement","LensflareElement","addElement","copy","light","toLowerCase","hasTarget","add","updateMatrixWorld","set","x","y","z","update","oldData","remove","pause","play","Mesh","Geometry","MeshBasicMaterial","opacity","transparent","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","DataTexture","Uint8Array","RGBFormat","minFilter","NearestFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","needsUpdate","occlusionMap","geometry","material1a","RawShaderMaterial","uniforms","scale","value","screenPosition","vertexShader","join","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","Shader","material2","color","Vector2","blending","AdditiveBlending","mesh2","element","push","screenPositionPixels","validArea","Box2","viewport","Vector4","onBeforeRender","renderer","camera","getCurrentViewport","invAspect","w","halfViewportWidth","halfViewportHeight","min","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","distance","uniformsNeedUpdate","dispose","prototype","Object","create","constructor","isLensflare","BufferGeometry","float32Array","Float32Array","interleavedBuffer","InterleavedBuffer","setIndex","addAttribute","InterleavedBufferAttribute"],"mappings":"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","file":"aframe-lensflare-component.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global AFRAME */\n\t/* global THREE */\n\t\n\tif (typeof AFRAME === 'undefined') {\n\t  throw new Error('Component attempted to register before AFRAME was available.');\n\t}\n\t\n\tif (typeof THREE === 'undefined') {\n\t  throw new Error('Component attempted to register before THREE was available.');\n\t}\n\t\n\t//https://github.com/mrdoob/three.js/blob/master/examples/js/objects/Lensflare.js\n\t__webpack_require__(1);\n\t\n\t/**\n\t * A-Frame Lensflare Component component for A-Frame.\n\t */\n\tAFRAME.registerComponent('lensflare', {\n\t  schema: {\n\t    src: {\n\t      type: 'asset'\n\t    },\n\t    createLight: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    position: {\n\t      type: 'vec3'\n\t    },\n\t    target: {\n\t      type: 'string'\n\t    },\n\t    intensity: {\n\t      type: 'number',\n\t      default: 5\n\t    },\n\t    relative: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    size: {\n\t      type: 'number',\n\t      default: 500\n\t    },\n\t    lightColor: {\n\t      type: 'string',\n\t      default: 'rgb(255, 255, 255)'\n\t    },\n\t    lightDistance: {\n\t      type: 'number',\n\t      default: 4.0\n\t    },\n\t    lightAngle: {\n\t      type: 'number',\n\t      default: Math.PI / 3\n\t    },\n\t    lightPenumbra: {\n\t      type: 'number',\n\t      default: 0.077\n\t    },\n\t    lightDecay: {\n\t      type: 'number',\n\t      default: 1\n\t    },\n\t    lightType: {\n\t      default: 'spot',\n\t      oneOf: ['directional', 'point', 'spot']\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Set if component needs multiple instancing.\n\t   */\n\t  multiple: true,\n\t\n\t  /**\n\t   * setLightType - Create a light based on lightType\n\t   *\n\t   * @param  {String} type Type of the light, supplied as a string.\n\t   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n\t   * @return {THREE.Light}  A THREE.JS light object\n\t   */\n\t  setLightType: function setLightType(type, settings) {\n\t    switch (type) {\n\t      case 'spot':\n\t        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay);\n\t      case 'point':\n\t        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay);\n\t      case 'directional':\n\t        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity);\n\t    }\n\t  },\n\t  /**\n\t   * Called once when component is attached. Generally for initial setup.\n\t   */\n\t  init: function init() {\n\t\n\t    var scene = document.querySelector('a-scene').object3D;\n\t    var parentEl = this.el.object3D;\n\t    var sceneEl = this.el.sceneEl.object3D;\n\t\n\t    //Determine positioning\n\t    var position = this.data.relative ? new THREE.Vector3(0, 0, 0) : this.data.position;\n\t\n\t    //Load texture (Three r84 upward doesn't support progress)\n\t    var textureLoader = new THREE.TextureLoader();\n\t    var textureFlare = textureLoader.load(this.data.src.currentSrc, function (texture) {\n\t      return texture;\n\t    }, undefined, function (error) {\n\t      throw new Error('An error occured loading the Flare texture');\n\t    });\n\t\n\t    this.lensFlare = new THREE.Lensflare();\n\t    this.lensFlareElement = new THREE.LensflareElement(textureFlare, this.data.size, 0.0, new THREE.Color(this.data.lightColor));\n\t    this.lensFlare.addElement(this.lensFlareElement);\n\t    this.lensFlare.position.copy(position);\n\t\n\t    //Determine if the user wants a light\n\t    if (this.data.createLight) {\n\t\n\t      var light = this.setLightType(this.data.lightType.toLowerCase(), this.data);\n\t\n\t      //Has a target been supplied?\n\t      var hasTarget = this.data.target ? this.data.target : false;\n\t\n\t      //Set light target.\n\t      if (hasTarget) {\n\t        light.target = document.querySelector(this.data.target).object3D;\n\t        sceneEl.add(light.target);\n\t        sceneEl.updateMatrixWorld();\n\t      }\n\t      light.position.set(position.x, position.y, position.z);\n\t\n\t      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n\t      if (this.data.relative) {\n\t        light.add(this.lensFlare);\n\t        parentEl.add(light);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(light);\n\t      }\n\t    } else {\n\t      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n\t      if (this.data.relative) {\n\t        parentEl.add(this.lensFlare);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(this.lensFlare);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Called when component is attached and when component data changes.\n\t   * Generally modifies the entity based on the data.\n\t   */\n\t  update: function update(oldData) {},\n\t\n\t  /**\n\t   * Called when a component is removed (e.g., via removeAttribute).\n\t   * Generally undoes all modifications to the entity.\n\t   */\n\t  remove: function remove() {},\n\t\n\t  /**\n\t   * Called on each scene tick.\n\t   */\n\t  // tick: function (t) { },\n\t\n\t  /**\n\t   * Called when entity pauses.\n\t   * Use to stop or remove any dynamic or background behavior such as events.\n\t   */\n\t  pause: function pause() {},\n\t\n\t  /**\n\t   * Called when entity resumes.\n\t   * Use to continue or add any dynamic or background behavior such as events.\n\t   */\n\t  play: function play() {}\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\n\t\n\tTHREE.Lensflare = function () {\n\t\n\t\tTHREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({ opacity: 0, transparent: true }));\n\t\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\t\n\t\t//\n\t\n\t\tvar positionScreen = new THREE.Vector3();\n\t\tvar positionView = new THREE.Vector3();\n\t\n\t\t// textures\n\t\n\t\tvar tempMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);\n\t\ttempMap.minFilter = THREE.NearestFilter;\n\t\ttempMap.magFilter = THREE.NearestFilter;\n\t\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\t\ttempMap.needsUpdate = true;\n\t\n\t\tvar occlusionMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);\n\t\tocclusionMap.minFilter = THREE.NearestFilter;\n\t\tocclusionMap.magFilter = THREE.NearestFilter;\n\t\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.needsUpdate = true;\n\t\n\t\t// material\n\t\n\t\tvar geometry = THREE.Lensflare.Geometry;\n\t\n\t\tvar material1a = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'void main() {', '\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\t\tfragmentShader: ['precision highp float;', 'void main() {', '\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );', '}'].join('\\n'),\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t});\n\t\n\t\tvar material1b = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\t\tfragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'varying vec2 vUV;', 'void main() {', '\tgl_FragColor = texture2D( map, vUV );', '}'].join('\\n'),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t});\n\t\n\t\t// the following object is used for occlusionMap generation\n\t\n\t\tvar mesh1 = new THREE.Mesh(geometry, material1a);\n\t\n\t\t//\n\t\n\t\tvar elements = [];\n\t\n\t\tvar shader = THREE.LensflareElement.Shader;\n\t\n\t\tvar material2 = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new THREE.Color(0xffffff) },\n\t\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t});\n\t\n\t\tvar mesh2 = new THREE.Mesh(geometry, material2);\n\t\n\t\tthis.addElement = function (element) {\n\t\n\t\t\telements.push(element);\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar scale = new THREE.Vector2();\n\t\tvar screenPositionPixels = new THREE.Vector2();\n\t\tvar validArea = new THREE.Box2();\n\t\tvar viewport = new THREE.Vector4();\n\t\n\t\tthis.onBeforeRender = function (renderer, scene, camera) {\n\t\n\t\t\trenderer.getCurrentViewport(viewport);\n\t\n\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\t\tvar halfViewportHeight = viewport.w / 2.0;\n\t\n\t\t\tvar size = 16 / viewport.w;\n\t\t\tscale.set(size * invAspect, size);\n\t\n\t\t\tvalidArea.min.set(viewport.x, viewport.y);\n\t\t\tvalidArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n\t\n\t\t\t// calculate position in screen space\n\t\n\t\t\tpositionView.setFromMatrixPosition(this.matrixWorld);\n\t\t\tpositionView.applyMatrix4(camera.matrixWorldInverse);\n\t\n\t\t\tif (positionView.z > 0) return; // lensflare is behind the camera\n\t\n\t\t\tpositionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n\t\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\tscreenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n\t\n\t\t\t// screen cull\n\t\n\t\t\tif (validArea.containsPoint(screenPositionPixels)) {\n\t\n\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\trenderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n\t\n\t\t\t\t// render pink quad\n\t\n\t\t\t\tvar uniforms = material1a.uniforms;\n\t\t\t\tuniforms[\"scale\"].value = scale;\n\t\t\t\tuniforms[\"screenPosition\"].value = positionScreen;\n\t\n\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);\n\t\n\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\trenderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n\t\n\t\t\t\t// restore graphics\n\t\n\t\t\t\tvar uniforms = material1b.uniforms;\n\t\t\t\tuniforms[\"scale\"].value = scale;\n\t\t\t\tuniforms[\"screenPosition\"].value = positionScreen;\n\t\n\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);\n\t\n\t\t\t\t// render elements\n\t\n\t\t\t\tvar vecX = -positionScreen.x * 2;\n\t\t\t\tvar vecY = -positionScreen.y * 2;\n\t\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++) {\n\t\n\t\t\t\t\tvar element = elements[i];\n\t\n\t\t\t\t\tvar uniforms = material2.uniforms;\n\t\n\t\t\t\t\tuniforms[\"color\"].value.copy(element.color);\n\t\t\t\t\tuniforms[\"map\"].value = element.texture;\n\t\t\t\t\tuniforms[\"screenPosition\"].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[\"screenPosition\"].value.y = positionScreen.y + vecY * element.distance;\n\t\n\t\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\n\t\t\t\t\tuniforms[\"scale\"].value.set(size * invAspect, size);\n\t\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\t\n\t\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tthis.dispose = function () {\n\t\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\t\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\t\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++) {\n\t\n\t\t\t\telements[i].texture.dispose();\n\t\t\t}\n\t\t};\n\t};\n\t\n\tTHREE.Lensflare.prototype = Object.create(THREE.Mesh.prototype);\n\tTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\n\tTHREE.Lensflare.prototype.isLensflare = true;\n\t\n\t//\n\t\n\tTHREE.LensflareElement = function (texture, size, distance, color) {\n\t\n\t\tthis.texture = texture;\n\t\tthis.size = size || 1;\n\t\tthis.distance = distance || 0;\n\t\tthis.color = color || new THREE.Color(0xffffff);\n\t};\n\t\n\tTHREE.LensflareElement.Shader = {\n\t\n\t\tuniforms: {\n\t\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: null },\n\t\t\t'color': { value: null },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\t\n\t\t},\n\t\n\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'uniform sampler2D occlusionMap;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '\tvUV = uv;', '\tvec2 pos = position.xy;', '\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );', '\tvVisibility =        visibility.r / 9.0;', '\tvVisibility *= 1.0 - visibility.g / 9.0;', '\tvVisibility *=       visibility.b / 9.0;', '\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\n\t\tfragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '\tvec4 texture = texture2D( map, vUV );', '\ttexture.a *= vVisibility;', '\tgl_FragColor = texture;', '\tgl_FragColor.rgb *= color;', '}'].join('\\n')\n\t\n\t};\n\t\n\tTHREE.Lensflare.Geometry = function () {\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n\t\n\t\tvar interleavedBuffer = new THREE.InterleavedBuffer(float32Array, 5);\n\t\n\t\tgeometry.setIndex([0, 1, 2, 0, 2, 3]);\n\t\tgeometry.addAttribute('position', new THREE.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\t\tgeometry.addAttribute('uv', new THREE.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n\t\n\t\treturn geometry;\n\t}();\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// aframe-lensflare-component.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2c280269332efe31211c","/* global AFRAME */\n/* global THREE */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.')\n}\n\nif (typeof THREE === 'undefined') {\n  throw new Error('Component attempted to register before THREE was available.')\n}\n\n//https://github.com/mrdoob/three.js/blob/master/examples/js/objects/Lensflare.js\nrequire('./Lensflare')\n\n/**\n * A-Frame Lensflare Component component for A-Frame.\n */\nAFRAME.registerComponent('lensflare', {\n  schema: {\n    src: {\n      type: 'asset'\n    },\n    createLight: {\n      type: 'boolean',\n      default: true\n    },\n    position: {\n      type: 'vec3'\n    },\n    target: {\n      type: 'string'\n    },\n    intensity: {\n      type: 'number',\n      default: 5\n    },\n    relative: {\n      type: 'boolean',\n      default: true\n    },\n    size: {\n      type: 'number',\n      default: 500\n    },\n    lightColor: {\n      type: 'string',\n      default: 'rgb(255, 255, 255)'\n    },\n    lightDistance: {\n      type: 'number',\n      default: 4.0,\n    },\n    lightAngle: {\n      type: 'number',\n      default: Math.PI / 3,\n    },\n    lightPenumbra: {\n      type: 'number',\n      default: 0.077,\n    },\n    lightDecay: {\n      type: 'number',\n      default: 1,\n    },\n    lightType: {\n      default: 'spot',\n      oneOf: ['directional', 'point', 'spot']\n    }\n  },\n\n  /**\n   * Set if component needs multiple instancing.\n   */\n  multiple: true,\n\n  /**\n   * setLightType - Create a light based on lightType\n   *\n   * @param  {String} type Type of the light, supplied as a string.\n   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n   * @return {THREE.Light}  A THREE.JS light object\n   */\n  setLightType: function (type, settings) {\n    switch (type) {\n      case 'spot':\n        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay)\n      case 'point':\n        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay)\n      case 'directional':\n        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity)\n    }\n  },\n  /**\n   * Called once when component is attached. Generally for initial setup.\n   */\n  init: function () {\n\n    const scene = document.querySelector('a-scene').object3D;\n    const parentEl = this.el.object3D\n    const sceneEl = this.el.sceneEl.object3D\n\n    //Determine positioning\n    const position = this.data.relative ? new THREE.Vector3(0, 0, 0) : this.data.position\n\n    //Load texture (Three r84 upward doesn't support progress)\n    const textureLoader = new THREE.TextureLoader()\n    const textureFlare = textureLoader.load(this.data.src.currentSrc,\n      function (texture) {\n        return texture\n      },\n      undefined,\n      function (error) {\n        throw new Error('An error occured loading the Flare texture')\n      }\n    )\n\n    this.lensFlare = new THREE.Lensflare()\n    this.lensFlareElement = new THREE.LensflareElement(textureFlare, this.data.size, 0.0, new THREE.Color(this.data.lightColor))\n    this.lensFlare.addElement(this.lensFlareElement);\n    this.lensFlare.position.copy(position)\n\n\n\n    //Determine if the user wants a light\n    if (this.data.createLight) {\n\n      const light = this.setLightType(this.data.lightType.toLowerCase(), this.data)\n\n      //Has a target been supplied?\n      const hasTarget = this.data.target ? this.data.target : false\n\n      //Set light target.\n      if (hasTarget) {\n        light.target = document.querySelector(this.data.target).object3D\n        sceneEl.add(light.target)\n        sceneEl.updateMatrixWorld()\n      }\n      light.position.set(position.x, position.y, position.z)\n\n      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n      if (this.data.relative) {\n        light.add(this.lensFlare)\n        parentEl.add(light)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(light)\n      }\n    } else {\n      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n      if (this.data.relative) {\n        parentEl.add(this.lensFlare)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(this.lensFlare)\n      }\n    }\n\n\n  },\n\n  /**\n   * Called when component is attached and when component data changes.\n   * Generally modifies the entity based on the data.\n   */\n  update: function (oldData) {\n\n  },\n\n  /**\n   * Called when a component is removed (e.g., via removeAttribute).\n   * Generally undoes all modifications to the entity.\n   */\n  remove: function () { },\n\n  /**\n   * Called on each scene tick.\n   */\n  // tick: function (t) { },\n\n  /**\n   * Called when entity pauses.\n   * Use to stop or remove any dynamic or background behavior such as events.\n   */\n  pause: function () { },\n\n  /**\n   * Called when entity resumes.\n   * Use to continue or add any dynamic or background behavior such as events.\n   */\n  play: function () { }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Lensflare = function () {\r\n\r\n\tTHREE.Mesh.call( this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } ) );\r\n\r\n\tthis.type = 'Lensflare';\r\n\tthis.frustumCulled = false;\r\n\tthis.renderOrder = Infinity;\r\n\r\n\t//\r\n\r\n\tvar positionScreen = new THREE.Vector3();\r\n\tvar positionView = new THREE.Vector3();\r\n\r\n\t// textures\r\n\r\n\tvar tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\r\n\ttempMap.minFilter = THREE.NearestFilter;\r\n\ttempMap.magFilter = THREE.NearestFilter;\r\n\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\r\n\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\r\n\ttempMap.needsUpdate = true;\r\n\r\n\tvar occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\r\n\tocclusionMap.minFilter = THREE.NearestFilter;\r\n\tocclusionMap.magFilter = THREE.NearestFilter;\r\n\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\r\n\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\r\n\tocclusionMap.needsUpdate = true;\r\n\r\n\t// material\r\n\r\n\tvar geometry = THREE.Lensflare.Geometry;\r\n\r\n\tvar material1a = new THREE.RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'scale': { value: null },\r\n\t\t\t'screenPosition': { value: null }\r\n\t\t},\r\n\t\tvertexShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform vec3 screenPosition;',\r\n\t\t\t'uniform vec2 scale;',\r\n\r\n\t\t\t'attribute vec3 position;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tdepthTest: true,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: false\r\n\t} );\r\n\r\n\tvar material1b = new THREE.RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'map': { value: tempMap },\r\n\t\t\t'scale': { value: null },\r\n\t\t\t'screenPosition': { value: null }\r\n\t\t},\r\n\t\tvertexShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform vec3 screenPosition;',\r\n\t\t\t'uniform vec2 scale;',\r\n\r\n\t\t\t'attribute vec3 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tvUV = uv;',\r\n\r\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t'precision highp float;',\r\n\r\n\t\t\t'uniform sampler2D map;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ),\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false,\r\n\t\ttransparent: false\r\n\t} );\r\n\r\n\t// the following object is used for occlusionMap generation\r\n\r\n\tvar mesh1 = new THREE.Mesh( geometry, material1a );\r\n\r\n\t//\r\n\r\n\tvar elements = [];\r\n\r\n\tvar shader = THREE.LensflareElement.Shader;\r\n\r\n\tvar material2 = new THREE.RawShaderMaterial( {\r\n\t\tuniforms: {\r\n\t\t\t'map': { value: null },\r\n\t\t\t'occlusionMap': { value: occlusionMap },\r\n\t\t\t'color': { value: new THREE.Color( 0xffffff ) },\r\n\t\t\t'scale': { value: new THREE.Vector2() },\r\n\t\t\t'screenPosition': { value: new THREE.Vector3() }\r\n\t\t},\r\n\t\tvertexShader: shader.vertexShader,\r\n\t\tfragmentShader: shader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true,\r\n\t\tdepthWrite: false\r\n\t} );\r\n\r\n\tvar mesh2 = new THREE.Mesh( geometry, material2 );\r\n\r\n\tthis.addElement = function ( element ) {\r\n\r\n\t\telements.push( element );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tvar scale = new THREE.Vector2();\r\n\tvar screenPositionPixels = new THREE.Vector2();\r\n\tvar validArea = new THREE.Box2();\r\n\tvar viewport = new THREE.Vector4();\r\n\r\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\trenderer.getCurrentViewport( viewport );\r\n\r\n\t\tvar invAspect = viewport.w / viewport.z;\r\n\t\tvar halfViewportWidth = viewport.z / 2.0;\r\n\t\tvar halfViewportHeight = viewport.w / 2.0;\r\n\r\n\t\tvar size = 16 / viewport.w;\r\n\t\tscale.set( size * invAspect, size );\r\n\r\n\t\tvalidArea.min.set( viewport.x, viewport.y );\r\n\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\r\n\r\n\t\t// calculate position in screen space\r\n\r\n\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\r\n\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\r\n\r\n\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\r\n\r\n\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\r\n\r\n\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\r\n\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\r\n\t\t// screen cull\r\n\r\n\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\r\n\r\n\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\r\n\r\n\t\t\t// render pink quad\r\n\r\n\t\t\tvar uniforms = material1a.uniforms;\r\n\t\t\tuniforms[ \"scale\" ].value = scale;\r\n\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\r\n\r\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\r\n\r\n\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\r\n\r\n\t\t\t// restore graphics\r\n\r\n\t\t\tvar uniforms = material1b.uniforms;\r\n\t\t\tuniforms[ \"scale\" ].value = scale;\r\n\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\r\n\r\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\r\n\r\n\t\t\t// render elements\r\n\r\n\t\t\tvar vecX = - positionScreen.x * 2;\r\n\t\t\tvar vecY = - positionScreen.y * 2;\r\n\r\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar element = elements[ i ];\r\n\r\n\t\t\t\tvar uniforms = material2.uniforms;\r\n\r\n\t\t\t\tuniforms[ \"color\" ].value.copy( element.color );\r\n\t\t\t\tuniforms[ \"map\" ].value = element.texture;\r\n\t\t\t\tuniforms[ \"screenPosition\" ].value.x = positionScreen.x + vecX * element.distance;\r\n\t\t\t\tuniforms[ \"screenPosition\" ].value.y = positionScreen.y + vecY * element.distance;\r\n\r\n\t\t\t\tvar size = element.size / viewport.w;\r\n\t\t\t\tvar invAspect = viewport.w / viewport.z;\r\n\r\n\t\t\t\tuniforms[ \"scale\" ].value.set( size * invAspect, size );\r\n\r\n\t\t\t\tmaterial2.uniformsNeedUpdate = true;\r\n\r\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\tmaterial1a.dispose();\r\n\t\tmaterial1b.dispose();\r\n\t\tmaterial2.dispose();\r\n\r\n\t\ttempMap.dispose();\r\n\t\tocclusionMap.dispose();\r\n\r\n\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\r\n\r\n\t\t\telements[ i ].texture.dispose();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Lensflare.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\r\nTHREE.Lensflare.prototype.isLensflare = true;\r\n\r\n//\r\n\r\nTHREE.LensflareElement = function ( texture, size, distance, color ) {\r\n\r\n\tthis.texture = texture;\r\n\tthis.size = size || 1;\r\n\tthis.distance = distance || 0;\r\n\tthis.color = color || new THREE.Color( 0xffffff );\r\n\r\n};\r\n\r\nTHREE.LensflareElement.Shader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'map': { value: null },\r\n\t\t'occlusionMap': { value: null },\r\n\t\t'color': { value: null },\r\n\t\t'scale': { value: null },\r\n\t\t'screenPosition': { value: null }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t'precision highp float;',\r\n\r\n\t\t'uniform vec3 screenPosition;',\r\n\t\t'uniform vec2 scale;',\r\n\r\n\t\t'uniform sampler2D occlusionMap;',\r\n\r\n\t\t'attribute vec3 position;',\r\n\t\t'attribute vec2 uv;',\r\n\r\n\t\t'varying vec2 vUV;',\r\n\t\t'varying float vVisibility;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvUV = uv;',\r\n\r\n\t\t'\tvec2 pos = position.xy;',\r\n\r\n\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\r\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\r\n\r\n\t\t'\tvVisibility =        visibility.r / 9.0;',\r\n\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\r\n\t\t'\tvVisibility *=       visibility.b / 9.0;',\r\n\r\n\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' ),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t'precision highp float;',\r\n\r\n\t\t'uniform sampler2D map;',\r\n\t\t'uniform vec3 color;',\r\n\r\n\t\t'varying vec2 vUV;',\r\n\t\t'varying float vVisibility;',\r\n\r\n\t\t'void main() {',\r\n\r\n\t\t'\tvec4 texture = texture2D( map, vUV );',\r\n\t\t'\ttexture.a *= vVisibility;',\r\n\t\t'\tgl_FragColor = texture;',\r\n\t\t'\tgl_FragColor.rgb *= color;',\r\n\r\n\t\t'}'\r\n\r\n\t].join( '\\n' )\r\n\r\n};\r\n\r\nTHREE.Lensflare.Geometry = ( function () {\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar float32Array = new Float32Array( [\r\n\t\t- 1, - 1, 0, 0, 0,\r\n\t\t1, - 1, 0, 1, 0,\r\n\t\t1, 1, 0, 1, 1,\r\n\t\t- 1, 1, 0, 0, 1\r\n\t] );\r\n\r\n\tvar interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );\r\n\r\n\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\r\n\tgeometry.addAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\r\n\tgeometry.addAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\r\n\r\n\treturn geometry;\r\n\r\n} )();\r\n\n\n\n// WEBPACK FOOTER //\n// ./Lensflare.js"],"sourceRoot":""}